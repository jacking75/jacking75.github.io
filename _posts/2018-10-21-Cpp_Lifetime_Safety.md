---
layout: post
title: C++ - C++의 dangling 검출, 제안 문서 버전 1.0 공개
published: true
categories: [C++]
tags: c++ memory dangling Herb_Sutter
---
[출처](http://www.infoworld.com/article/3307522/c-plus-plus/revised-proposal-could-solve-longstanding-c-bugs.html )  

C++의 저명한 개발자, ISO C++ 표준위원회의 위원장 Herb Sutter씨가 dangling(잘못된 영역에 대한 잘못된 참조)의 검출 방법을 제안하는 문서 "Lifetime Safety: Preventing Common Danglng"의 버전 1.0을 공개 했다.  
C++ 코드에 숨어있는 전형적인 dangling을 컴파일 시에 발견하고 경고하는 방법을 제안하고 있다.  
수년 동안 존재 해 온 문제를 해결하고 코드의 안전성을 높이는 것을 목표로 한다.  


이번 문서는 2015년 발표한 0.9 버전에 이은 것. Sutter씨에 따르면, 원래는 정보 제공에 의한 기여를 목적으로 한 기술이었지만, C++ 표준으로의 채택을 향한 움직임이 될 가능성도 있다.  
 
버전 1.0에서는 C언어 스타일의 포인터나 참조 반복자, string_view, span 등 다른 곳에서 확보한 영역의 데이터를 참조하는 형태의 취급에 대해 거론하고, C++ 코드에서의 전형적인 dangling을 컴파일 할 때 감지하고 일관성 있는 형태로 오류로 제시 할 수 있도록 하기 위한 방법을 제안하고 있다. 문서 초록에는 이 노력에 대해 40년 전부터 문제를 해결하기 위한 중대 하면서도 추론적인 시도라고 기술 하고 있다.  
 
이 문서가 제시하는 방법은 코드에서 변수를 스마트 포인터나 컨테이너 라는 "Owner" 타입과 string_view와 span 등의 "Pointer" 유형에 개괄적으로 구분한다. 그리고 로컬에서 간단한 ACFG(Acyclic Control Flow Graph) 분석을 사용하여 Pointer 유형의 각 변수의 참조를 추적하고 Owner 유형의 변수의 변경에 의해 Pointer 유형의 변수가 비활성화 되는 시간을 특정한다.  
이 분석에서는 범위 객체의 라이프 타임, const 등 현대적인 코드에서 유용한 힌트가 되는 C++의 기존 개념을 활용한다. 약간의 확장을 더하면 로컬 move 후 변수의 사용을 감지 할 수 있을 것 같다.  

경고는 어느 구현에서도 일관된 결과를 반환 하도록 통합 할 수 있으며, Clang과 MSVC에서의 부분적인 구현에서도 이 점은 입증 되고 있다. 또한 처리는 효율적이고 일반적인 컴파일 시에 실행할 수있다.  
예를 들어, 현재 Clang 기반의 구현은 최적화 되지 않고 수행 할 작업에 낭비가 있지만, 그래도 LLVM의 큰 번역 단위의 컴파일 시 발생하는 오버 헤드는 10% 미만이다.  

이 제안의 시도가 잘 안될 가능성도 있는 것은 Sutter씨도 인정하고 있지만, 비록 공식적인 표준화 말고도 C++ 컴파일러에 dangling  검출이 사실상 구현되면, 이 기술의 가치가 현실로 될수도 있다고 그는 말한다. 일반적인 벤더 확장으로서 dangling을  주요 컴파일러에서 제대로 감지 할 수 있게 되면, 포인터, 반복자, string_view 등과 관련하여 C++은 dangling의 온상이라는 악명의 불식과 개선으로 이어진다.  

이번 문서가 채택하고 있는 이러한 문제에 관해서는 이 이외에도 제안이 나와 있고, 언어와 표준 라이브러리에서 광범위한 어노테이션을 공식적으로 표준화 하는 제안 등이 있다.  


